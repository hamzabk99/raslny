<!DOCTYPE html>
<html>
<head>
  <title>Chat</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="styles.css?v=14">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <div id="authScreen">
    <div class="auth-container">
      <h1>Chat</h1>
      <button class="google-btn" onclick="signInWithGoogle()">
        <img src="https://www.google.com/favicon.ico" alt="Google Icon">
        Sign in with Google
      </button>
    </div>
  </div>

  <div id="chatApp" style="display: none;">
    <div id="userList">
      <div id="userHeader">
        <img id="userPhoto" alt="Your photo">
        <span id="userName"></span>
        <button onclick="showProfile()" id="profileBtn">Profile</button>
        <button onclick="signOut()" id="signOutBtn">Sign Out</button>
      </div>
      <div id="createContainer">
        <button onclick="createChannel()">Create Channel</button>
        <button onclick="createGroup()">Create Group</button>
      </div>
      <div id="searchContainer">
        <input id="searchInput" placeholder="Search by username (e.g., channel1, group2)..." oninput="searchEntities()">
        <div id="searchResults"></div>
      </div>
      <div id="contacts"></div>
      <div id="requestsContainer">
        <h3>Pending Requests</h3>
        <div id="pendingRequests"></div>
      </div>
    </div>
    <div id="chatWindow" style="display: none;">
      <div id="chatHeader">
        <button class="back-btn" onclick="showUserList()">←</button>
        <span id="currentChat">Select a contact</span>
        <button id="callBtn" style="display: none;" onclick="startCall()">Call</button>
        <button id="addAdminBtn" style="display: none;" onclick="addAdmin()">Add Admin</button>
      </div>
      <div id="messages"></div>
      <div class="input-container" id="messageInputContainer">
        <input id="messageInput" placeholder="Type a message..." onkeydown="if (event.key === 'Enter') sendMessage()" />
        <button onclick="sendMessage()">Send</button>
      </div>
    </div>
    <div id="profilePage" style="display: none;">
      <div id="profileHeader">
        <button class="back-btn" onclick="showUserList()">←</button>
        <h2>Profile</h2>
      </div>
      <div id="profileContent">
        <img id="profilePhoto" alt="Your photo">
        <input id="profileName" placeholder="Your Name">
        <p id="profileUsername">Username: <span id="fixedUsername"></span></p>
        <button onclick="saveProfile()">Save</button>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyA3h2VF-GeE_AKjKcsbDF-zw1n1Y9Z_ckA",
      authDomain: "web-chat-eaa23.firebaseapp.com",
      projectId: "web-chat-eaa23",
      storageBucket: "web-chat-eaa23.firebasestorage.app",
      messagingSenderId: "640664372760",
      appId: "1:640664372760:web:8b44f49ac91a4465b1256d"
    };

    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    let currentUser = null;
    let currentReceiver = null;
    let currentEntityType = null; // 'user', 'channel', or 'group'

    function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      return auth.signInWithPopup(provider)
        .then((result) => console.log("Sign-in successful:", result.user.uid))
        .catch(error => {
          console.error("Sign-in error:", error);
          alert("Failed to sign in: " + error.message);
        });
    }

    function signOut() {
      auth.signOut();
      window.location.reload();
    }

    auth.onAuthStateChanged(user => {
      const authScreen = document.getElementById('authScreen');
      const chatApp = document.getElementById('chatApp');
      const userList = document.getElementById('userList');
      
      if (user) {
        currentUser = user;
        authScreen.style.display = 'none';
        chatApp.style.display = 'flex';
        userList.classList.add('active');
        document.getElementById('userPhoto').src = user.photoURL || '';
        document.getElementById('userName').textContent = user.displayName || 'User';
        checkUserExists(user);
        loadContacts();
        loadPendingRequests();
      } else {
        authScreen.style.display = 'flex';
        chatApp.style.display = 'none';
      }
    });

    function checkUserExists(user) {
      const userRef = db.collection('users').doc(user.uid);
      userRef.get().then(doc => {
        if (!doc.exists) {
          assignUsername(user);
        }
      }).catch(error => {
        console.error("Error checking user:", error);
        resetUsernames();
      });
    }

    function assignUsername(user) {
      const counterRef = db.collection('metadata').doc('userCounter');
      db.runTransaction(transaction => {
        return transaction.get(counterRef).then(counterDoc => {
          let nextId = 1;
          if (counterDoc.exists) nextId = counterDoc.data().count + 1;
          transaction.set(counterRef, { count: nextId }, { merge: true });
          transaction.set(userRef, {
            uid: user.uid,
            displayName: user.displayName,
            username: nextId.toString(),
            email: user.email,
            photoURL: user.photoURL,
            following: [],
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
          });
          return nextId;
        });
      }).then(nextId => console.log("User created with username:", nextId))
        .catch(error => {
          console.error("Error assigning username:", error);
          resetUsernames();
        });
    }

    function resetUsernames() {
      db.collection('users').get().then(snapshot => {
        const batch = db.batch();
        let counter = 1;
        snapshot.forEach(doc => {
          batch.update(db.collection('users').doc(doc.id), { username: counter.toString() });
          counter++;
        });
        batch.set(db.collection('metadata').doc('userCounter'), { count: counter - 1 });
        return batch.commit();
      }).then(() => {
        console.log("Usernames reset successfully");
        loadContacts();
      }).catch(error => console.error("Error resetting usernames:", error));
    }

    function createChannel() {
      const counterRef = db.collection('metadata').doc('channelCounter');
      db.runTransaction(transaction => {
        return transaction.get(counterRef).then(counterDoc => {
          let nextId = 1;
          if (counterDoc.exists) nextId = counterDoc.data().count + 1;
          transaction.set(counterRef, { count: nextId }, { merge: true });
          const channelRef = db.collection('channels').doc(`channel${nextId}`);
          transaction.set(channelRef, {
            name: `Channel ${nextId}`,
            username: `channel${nextId}`,
            creator: currentUser.uid,
            admins: [currentUser.uid],
            members: [currentUser.uid],
            type: 'channel',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });
          return nextId;
        });
      }).then(nextId => {
        console.log("Channel created:", `channel${nextId}`);
        loadContacts();
      }).catch(error => console.error("Error creating channel:", error));
    }

    function createGroup() {
      const counterRef = db.collection('metadata').doc('groupCounter');
      db.runTransaction(transaction => {
        return transaction.get(counterDoc => {
          let nextId = 1;
          if (counterDoc.exists) nextId = counterDoc.data().count + 1;
          transaction.set(counterRef, { count: nextId }, { merge: true });
          const groupRef = db.collection('groups').doc(`group${nextId}`);
          transaction.set(groupRef, {
            name: `Group ${nextId}`,
            username: `group${nextId}`,
            creator: currentUser.uid,
            members: [currentUser.uid],
            type: 'group',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
          });
          return nextId;
        });
      }).then(nextId => {
        console.log("Group created:", `group${nextId}`);
        loadContacts();
      }).catch(error => console.error("Error creating group:", error));
    }

    function loadContacts() {
      const contactsDiv = document.getElementById('contacts');
      contactsDiv.innerHTML = '';
      const seenIds = new Set();

      // Load followed users
      db.collection('users').doc(currentUser.uid).onSnapshot(doc => {
        const following = doc.data().following || [];
        following.forEach(followId => {
          seenIds.add(followId);
          db.collection('users').doc(followId).get().then(followDoc => {
            if (followDoc.exists) addContact(followDoc.data(), contactsDiv, 'user');
          });
        });
      });

      // Load channels and groups
      ['channels', 'groups'].forEach(collection => {
        db.collection(collection).where('members', 'array-contains', currentUser.uid)
          .onSnapshot(snapshot => {
            snapshot.forEach(doc => {
              if (!seenIds.has(doc.id)) {
                seenIds.add(doc.id);
                addContact(doc.data(), contactsDiv, collection === 'channels' ? 'channel' : 'group');
              }
            });
          });
      });

      // Load incoming messages from non-followed users
      db.collectionGroup('messages').where('receiver', '==', currentUser.uid)
        .orderBy('timestamp').onSnapshot(snapshot => {
          snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
              const msg = change.doc.data();
              const senderId = msg.sender;
              if (!seenIds.has(senderId)) {
                seenIds.add(senderId);
                db.collection('users').doc(senderId).get().then(senderDoc => {
                  if (senderDoc.exists) {
                    addContact(senderDoc.data(), contactsDiv, 'user');
                    updateNotification(senderId, msg.text);
                  }
                });
              } else {
                updateNotification(senderId, msg.text);
              }
            }
          });
        });
    }

    function addContact(data, container, type) {
      const id = type === 'user' ? data.uid : data.username;
      if (!document.querySelector(`.contact-item[data-id="${id}"]`)) {
        container.innerHTML += `
          <div class="contact-item" data-id="${id}" onclick="openChat('${id}', '${data.displayName || data.name}', '${type}')">
            <img src="${data.photoURL || 'data:,'}" onerror="this.src='data:,'">
            <span class="contact-name">${data.displayName || data.name} (@${data.username})</span>
            <span class="notification" id="notif-${id}"></span>
          </div>
        `;
      }
    }

    function updateNotification(id, text) {
      const notifElement = document.getElementById(`notif-${id}`);
      if (notifElement && id !== currentReceiver) {
        const preview = text.length > 20 ? text.substring(0, 20) + '...' : text;
        notifElement.textContent = preview;
      }
    }

    function searchEntities() {
      const query = document.getElementById('searchInput').value.trim();
      const searchResults = document.getElementById('searchResults');
      searchResults.innerHTML = '';
      
      if (!query) return;

      // Search channels
      db.collection('channels').where('username', '==', query).get()
        .then(snapshot => {
          snapshot.forEach(doc => handleSearchResult(doc.data(), 'channel', searchResults));
        });
      // Search groups
      db.collection('groups').where('username', '==', query).get()
        .then(snapshot => {
          snapshot.forEach(doc => handleSearchResult(doc.data(), 'group', searchResults));
        });
      // Search users
      db.collection('users').where('username', '==', query).get()
        .then(snapshot => {
          snapshot.forEach(doc => handleSearchResult(doc.data(), 'user', searchResults));
        });
    }

    function handleSearchResult(data, type, container) {
      if (type === 'user' && data.uid === currentUser.uid) return;
      const id = type === 'user' ? data.uid : data.username;
      container.innerHTML += `
        <div class="search-item" onclick="applyToJoin('${id}', '${type}')">
          <img src="${data.photoURL || 'data:,'}" onerror="this.src='data:,'">
          <span>${data.displayName || data.name} (@${data.username})</span>
          <button>Apply</button>
        </div>
      `;
    }

    function applyToJoin(id, type) {
      const requestRef = db.collection('requests').doc();
      requestRef.set({
        applicant: currentUser.uid,
        targetId: id,
        targetType: type,
        status: 'pending',
        createdAt: firebase.firestore.FieldValue.serverTimestamp()
      }).then(() => {
        console.log(`Applied to join ${type}: ${id}`);
        document.getElementById('searchInput').value = '';
        document.getElementById('searchResults').innerHTML = '';
      }).catch(error => console.error("Error applying:", error));
    }

    function loadPendingRequests() {
      const requestsDiv = document.getElementById('pendingRequests');
      db.collection('requests').where('status', '==', 'pending').onSnapshot(snapshot => {
        requestsDiv.innerHTML = '';
        snapshot.forEach(doc => {
          const request = doc.data();
          if (request.targetType === 'user') return;
          const entityRef = db.collection(request.targetType + 's').doc(request.targetId);
          entityRef.get().then(entityDoc => {
            if (entityDoc.exists && entityDoc.data().creator === currentUser.uid) {
              db.collection('users').doc(request.applicant).get().then(userDoc => {
                if (userDoc.exists) {
                  const user = userDoc.data();
                  requestsDiv.innerHTML += `
                    <div class="request-item">
                      <span>${user.displayName} (@${user.username}) wants to join ${request.targetId}</span>
                      <button onclick="acceptRequest('${doc.id}', '${request.applicant}', '${request.targetId}', '${request.targetType}')">Accept</button>
                      <button onclick="rejectRequest('${doc.id}')">Reject</button>
                    </div>
                  `;
                }
              });
            }
          });
        });
      });
    }

    function acceptRequest(requestId, applicantId, targetId, targetType) {
      const entityRef = db.collection(targetType + 's').doc(targetId);
      entityRef.update({
        members: firebase.firestore.FieldValue.arrayUnion(applicantId)
      }).then(() => {
        db.collection('requests').doc(requestId).update({ status: 'accepted' });
        console.log(`Accepted ${applicantId} into ${targetId}`);
        loadContacts();
      }).catch(error => console.error("Error accepting request:", error));
    }

    function rejectRequest(requestId) {
      db.collection('requests').doc(requestId).update({ status: 'rejected' })
        .then(() => console.log("Request rejected"))
        .catch(error => console.error("Error rejecting request:", error));
    }

    function openChat(id, name, type) {
      currentReceiver = id;
      currentEntityType = type;
      document.getElementById('currentChat').textContent = name;
      document.getElementById('userList').classList.remove('active');
      document.getElementById('chatWindow').style.display = 'flex';
      document.getElementById('profilePage').style.display = 'none';
      
      const inputContainer = document.getElementById('messageInputContainer');
      const callBtn = document.getElementById('callBtn');
      const addAdminBtn = document.getElementById('addAdminBtn');
      
      if (type === 'channel') {
        db.collection('channels').doc(id).get().then(doc => {
          const data = doc.data();
          inputContainer.style.display = data.admins.includes(currentUser.uid) ? 'flex' : 'none';
          addAdminBtn.style.display = data.admins.includes(currentUser.uid) ? 'inline' : 'none';
        });
        callBtn.style.display = 'none';
      } else if (type === 'group') {
        inputContainer.style.display = 'flex';
        callBtn.style.display = 'none';
        addAdminBtn.style.display = 'none';
      } else {
        inputContainer.style.display = 'flex';
        callBtn.style.display = 'inline';
        addAdminBtn.style.display = 'none';
      }
      
      loadMessages();
      const notifElement = document.getElementById(`notif-${id}`);
      if (notifElement) notifElement.textContent = '';
    }

    function showUserList() {
      document.getElementById('userList').classList.add('active');
      document.getElementById('chatWindow').style.display = 'none';
      document.getElementById('profilePage').style.display = 'none';
      currentReceiver = null;
      currentEntityType = null;
    }

    function showProfile() {
      document.getElementById('userList').classList.remove('active');
      document.getElementById('chatWindow').style.display = 'none';
      const profilePage = document.getElementById('profilePage');
      profilePage.style.display = 'flex';
      
      const userRef = db.collection('users').doc(currentUser.uid);
      userRef.get().then(doc => {
        const data = doc.data();
        document.getElementById('profilePhoto').src = data.photoURL || '';
        document.getElementById('profileName').value = data.displayName || '';
        document.getElementById('fixedUsername').textContent = data.username;
      }).catch(error => console.error("Error loading profile:", error));
    }

    function saveProfile() {
      const name = document.getElementById('profileName').value.trim();
      if (!name) {
        alert("Name cannot be empty");
        return;
      }
      const userRef = db.collection('users').doc(currentUser.uid);
      userRef.update({ displayName: name }).then(() => {
        document.getElementById('userName').textContent = name;
        showUserList();
        loadContacts();
      }).catch(error => {
        console.error("Error updating profile:", error);
        alert("Failed to update profile: " + error.message);
      });
    }

    function addAdmin() {
      const username = prompt("Enter username of new admin:");
      if (!username) return;
      
      db.collection('users').where('username', '==', username).get().then(snapshot => {
        if (snapshot.empty) {
          alert("User not found");
          return;
        }
        const userDoc = snapshot.docs[0];
        const userId = userDoc.id;
        db.collection('channels').doc(currentReceiver).update({
          admins: firebase.firestore.FieldValue.arrayUnion(userId)
        }).then(() => {
          console.log(`Added ${username} as admin`);
        }).catch(error => console.error("Error adding admin:", error));
      });
    }

    function startCall() {
      alert(`Simulating call to ${currentReceiver}. Real calling requires WebRTC setup.`);
      // WebRTC implementation would go here
    }

    function loadMessages() {
      if (!currentReceiver) return;
      
      let messagesRef;
      if (currentEntityType === 'user') {
        const chatId = [currentUser.uid, currentReceiver].sort().join('_');
        messagesRef = db.collection(`chats/${chatId}/messages`);
      } else {
        messagesRef = db.collection(`${currentEntityType}s/${currentReceiver}/messages`);
      }
      
      messagesRef.orderBy('timestamp').onSnapshot(snapshot => {
        const messagesDiv = document.getElementById('messages');
        messagesDiv.innerHTML = '';
        snapshot.forEach(doc => {
          const msg = doc.data();
          const isYou = msg.sender === currentUser.uid;
          messagesDiv.innerHTML += `
            <div class="message ${isYou ? 'you' : 'others'}">
              ${msg.text}
              <span class="timestamp">
                ${msg.timestamp ? new Date(msg.timestamp.toDate()).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'Sending...'}
              </span>
            </div>
          `;
        });
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
      });
    }

    function sendMessage() {
      if (!currentReceiver) {
        alert("Please select a contact.");
        return;
      }
      const input = document.getElementById('messageInput');
      const text = input.value.trim();
      if (!text) return;

      let messagesRef;
      if (currentEntityType === 'user') {
        const chatId = [currentUser.uid, currentReceiver].sort().join('_');
        messagesRef = db.collection(`chats/${chatId}/messages`);
      } else {
        messagesRef = db.collection(`${currentEntityType}s/${currentReceiver}/messages`);
        if (currentEntityType === 'channel') {
          db.collection('channels').doc(currentReceiver).get().then(doc => {
            if (!doc.data().admins.includes(currentUser.uid)) {
              alert("Only admins can send messages in channels.");
              return;
            }
          });
        }
      }

      messagesRef.add({
        text: text,
        sender: currentUser.uid,
        receiver: currentEntityType === 'user' ? currentReceiver : null,
        timestamp: firebase.firestore.FieldValue.serverTimestamp()
      }).then(() => {
        input.value = '';
        loadMessages();
      }).catch(error => {
        console.error("Error sending message:", error);
        alert("Failed to send message: " + error.message);
      });
    }
  </script>
</body>
</html>