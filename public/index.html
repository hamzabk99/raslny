<!DOCTYPE html>
<html>
<head>
  <title>Chat</title>
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="styles.css?v=16">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
  <div id="authScreen">
    <div class="auth-container">
      <h1>Chat</h1>
      <button class="google-btn" onclick="signInWithGoogle()">
        <img src="https://www.google.com/favicon.ico" alt="Google Icon">
        Sign in with Google
      </button>
    </div>
  </div>

  <div id="chatApp" style="display: none;">
    <div id="userList">
      <div id="userHeader">
        <img id="userPhoto" alt="Your photo">
        <span id="userName"></span>
        <button onclick="showProfile()" id="profileBtn">Profile</button>
        <button onclick="signOut()" id="signOutBtn">Sign Out</button>
      </div>
      <div id="searchContainer">
        <input id="searchInput" placeholder="Search by username (e.g., 1, 2)..." oninput="searchEntities()">
        <div id="searchResults"></div>
      </div>
      <div id="contacts"></div>
    </div>
    <div id="chatWindow" style="display: none;">
      <div id="chatHeader">
        <button class="back-btn" onclick="showUserList()">←</button>
        <span id="currentChat">Select a contact</span>
        <button id="callBtn" onclick="startCall()">Call</button>
        <button id="deleteBtn" onclick="deleteEntity()">Delete</button>
      </div>
      <div id="messages"></div>
      <div class="input-container" id="messageInputContainer">
        <input id="messageInput" placeholder="Type a message..." onkeydown="if (event.key === 'Enter') sendMessage()" />
        <button onclick="sendMessage()">Send</button>
      </div>
      <!-- Video call container -->
      <div id="videoContainer" style="display: none;">
        <video id="localVideo" autoplay muted></video>
        <video id="remoteVideo" autoplay></video>
      </div>
    </div>
    <div id="profilePage" style="display: none;">
      <div id="profileHeader">
        <button class="back-btn" onclick="showUserList()">←</button>
        <h2>Profile</h2>
      </div>
      <div id="profileContent">
        <img id="profilePhoto" alt="Your photo">
        <input id="profileName" placeholder="Your Name">
        <p id="profileUsername">Username: <span id="fixedUsername"></span></p>
        <button onclick="saveProfile()">Save</button>
      </div>
    </div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyA3h2VF-GeE_AKjKcsbDF-zw1n1Y9Z_ckA",
      authDomain: "web-chat-eaa23.firebaseapp.com",
      projectId: "web-chat-eaa23",
      storageBucket: "web-chat-eaa23.firebasestorage.app",
      messagingSenderId: "640664372760",
      appId: "1:640664372760:web:8b44f49ac91a4465b1256d"
    };

    const app = firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    const auth = firebase.auth();
    let currentUser = null;
    let currentReceiver = null;
    
    // WebRTC variables
    let peerConnection;
    const configuration = {
      iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
    };
    let localStream;
    let remoteStream;

    function signInWithGoogle() {
      const provider = new firebase.auth.GoogleAuthProvider();
      return auth.signInWithPopup(provider)
        .then((result) => console.log("Sign-in successful:", result.user.uid))
        .catch(error => console.error("Sign-in error:", error));
    }

    function signOut() {
      // Stop all media tracks when signing out
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
      }
      if (remoteStream) {
        remoteStream.getTracks().forEach(track => track.stop());
      }
      auth.signOut();
      window.location.reload();
    }

    auth.onAuthStateChanged(user => {
      const authScreen = document.getElementById('authScreen');
      const chatApp = document.getElementById('chatApp');
      const userList = document.getElementById('userList');
      
      if (user) {
        currentUser = user;
        authScreen.style.display = 'none';
        chatApp.style.display = 'flex';
        userList.classList.add('active');
        document.getElementById('userPhoto').src = user.photoURL || '';
        document.getElementById('userName').textContent = user.displayName || 'User';
        checkUserExists(user);
        loadContacts();

        // Listen for incoming calls
        db.collection('calls').doc(user.uid).onSnapshot(async (snapshot) => {
          const data = snapshot.data();
          if (!data || data.from === user.uid) return;

          if (confirm(`Incoming call from ${data.from}. Accept?`)) {
            await handleIncomingCall(data);
          } else {
            db.collection('calls').doc(user.uid).delete();
          }
        });

      } else {
        authScreen.style.display = 'flex';
        chatApp.style.display = 'none';
      }
    });

    // ... [Keep all the existing functions from your original code unchanged] ...

    async function startCall() {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById('localVideo').srcObject = localStream;
        document.getElementById('videoContainer').style.display = 'block';

        peerConnection = new RTCPeerConnection(configuration);

        // Setup ice candidate handling
        peerConnection.onicecandidate = async (event) => {
          if (event.candidate) {
            await db.collection('calls').doc(currentReceiver).collection('candidates').add({
              candidate: JSON.stringify(event.candidate),
              sender: currentUser.uid
            });
          }
        };

        peerConnection.ontrack = (event) => {
          remoteStream = event.streams[0];
          document.getElementById('remoteVideo').srcObject = remoteStream;
        };

        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        // Create offer
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        await db.collection('calls').doc(currentReceiver).set({
          offer: JSON.stringify(offer),
          from: currentUser.uid
        });

        listenForAnswer();
      } catch (error) {
        console.error('Error starting call:', error);
      }
    }

    async function listenForAnswer() {
      const callRef = db.collection('calls').doc(currentUser.uid);
      
      callRef.onSnapshot(async (snapshot) => {
        const data = snapshot.data();
        if (!data || !data.answer) return;

        const answer = JSON.parse(data.answer);
        if (!peerConnection.currentRemoteDescription) {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        }
        callRef.delete();
      });

      // Listen for ICE candidates
      db.collection('calls').doc(currentUser.uid).collection('candidates')
        .onSnapshot(snapshot => {
          snapshot.docChanges().forEach(async change => {
            if (change.type === 'added') {
              const data = change.doc.data();
              if (data.sender === currentReceiver) {
                const candidate = JSON.parse(data.candidate);
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
              }
            }
          });
        });
    }

    async function handleIncomingCall(data) {
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById('localVideo').srcObject = localStream;
        document.getElementById('videoContainer').style.display = 'block';

        peerConnection = new RTCPeerConnection(configuration);

        peerConnection.onicecandidate = async (event) => {
          if (event.candidate) {
            await db.collection('calls').doc(data.from).collection('candidates').add({
              candidate: JSON.stringify(event.candidate),
              sender: currentUser.uid
            });
          }
        };

        peerConnection.ontrack = (event) => {
          remoteStream = event.streams[0];
          document.getElementById('remoteVideo').srcObject = remoteStream;
        };

        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });

        await peerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(data.offer)));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        await db.collection('calls').doc(data.from).set({
          answer: JSON.stringify(answer)
        });

        // Listen for ICE candidates
        db.collection('calls').doc(data.from).collection('candidates')
          .onSnapshot(snapshot => {
            snapshot.docChanges().forEach(async change => {
              if (change.type === 'added') {
                const candidateData = change.doc.data();
                if (candidateData.sender === data.from) {
                  const candidate = JSON.parse(candidateData.candidate);
                  await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
              }
            });
          });
      } catch (error) {
        console.error('Error handling incoming call:', error);
      }
    }
  </script>

</body>
</html>